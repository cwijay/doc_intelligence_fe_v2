import axios, { AxiosResponse } from 'axios';
import {
  Organization as ApiOrganization,
  OrganizationCreateRequest,
  OrganizationUpdateRequest,
  OrganizationDeleteResponse,
  OrganizationList,
  OrganizationFilters,
  HealthCheck,
  User,
  UserCreateRequest,
  UserUpdateRequest,
  UserDeleteResponse,
  UserList,
  UserFilters,
  Folder,
  FolderCreateRequest,
  FolderUpdateRequest,
  FolderDeleteResponse,
  FolderList,
  FolderFilters,
  FolderMoveRequest,
  FolderStats,
  FolderTree,
  Document,
  DocumentCreateRequest,
  DocumentUpdateRequest,
  DocumentDeleteResponse,
  DocumentList,
  DocumentFilters,
  DocumentUploadResponse,
  DocumentStats,
  DocumentSummary,
  DocumentSummaryRequest,
  DocumentSummaryUpdateRequest,
  DocumentSummaryResponse,
  DocumentSummarizeResponse,
  DocumentFAQ,
  FAQItem,
  DocumentFAQRequest,
  DocumentFAQUpdateRequest,
  DocumentFAQResponse,
  DocumentFAQRetrievalResponse,
  DocumentQuestions,
  DocumentQuestionsRequest,
  DocumentQuestionsUpdateRequest,
  DocumentQuestionsResponse,
} from '@/types/api';
import {
  LoginRequest,
  LoginResponse,
  RegisterRequest,
  RegisterResponse,
  LogoutResponse,
  Organization,
  SessionUser,
} from '@/types/auth';
import { authService } from './auth';
import { clientConfig } from './config';

// Updated base URL to match API spec
const API_BASE_URL = clientConfig.apiUrl;

// API configuration

const api = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000, // Increased timeout for uploads
  headers: {
    'Content-Type': 'application/json',
  },
  // Add explicit axios configuration to help with CORS
  withCredentials: false,
});

// Note: Simplified approach - no token refresh, just redirect to login on 401

// Add session token to requests
api.interceptors.request.use(
  (config) => {
    const token = authService.getAccessToken();
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    console.error('Request interceptor error:', error);
    return Promise.reject(error);
  }
);

api.interceptors.response.use(
  (response) => response,
  async (error) => {
    let errorMessage = 'Unknown API error';
    
    // Handle 401 unauthorized responses with automatic logout
    if (error.response?.status === 401) {
      console.log('üö´ 401 Unauthorized - triggering automatic logout...');
      
      // Skip token refresh for auth endpoints to prevent refresh loops during login
      const isAuthEndpoint = error.config?.url?.includes('/auth/login') || 
                            error.config?.url?.includes('/auth/register') ||
                            error.config?.url?.includes('/auth/refresh');
      
      if (!isAuthEndpoint) {
        // Import AuthContext logout function if available
        try {
          // Check if we're in a browser environment
          if (typeof window !== 'undefined') {
            // Use window event to trigger logout across the app
            window.dispatchEvent(new CustomEvent('auth:unauthorized', {
              detail: { reason: '401_response', timestamp: new Date().toISOString() }
            }));
          }
        } catch (logoutError) {
          console.error('Failed to trigger automatic logout on 401:', logoutError);
        }
      }
    }
    
    // Basic error logging
    console.error('API Error:', error.message || error);
    
    // Handle different types of errors with improved messaging
    if (error.code === 'NETWORK_ERROR' || error.message === 'Network Error') {
      errorMessage = `Network connection failed. Ensure the backend server is running on ${clientConfig.apiBaseUrl} and try again.`;
    } else if (error.code === 'ERR_NETWORK') {
      errorMessage = `Cannot reach the API server. Please verify the backend is running on ${clientConfig.apiBaseUrl} and accessible.`;
    } else if (error.code === 'ECONNREFUSED') {
      errorMessage = `Connection refused. The API server at ${clientConfig.apiBaseUrl} is not responding.`;
    } else if (error.response) {
      // Server responded with error status
      if (error.response.data?.message) {
        errorMessage = error.response.data.message;
      } else if (error.response.data?.detail) {
        if (Array.isArray(error.response.data.detail)) {
          const details = error.response.data.detail;
          if (details.length > 0) {
            errorMessage = details.map((detail: any) => detail.msg || detail).join(', ');
          }
        } else {
          errorMessage = error.response.data.detail;
        }
      } else if (error.response.data?.error) {
        errorMessage = error.response.data.error;
      } else if (typeof error.response.data === 'string') {
        errorMessage = error.response.data;
      } else if (error.response.status) {
        // Create meaningful error messages for common HTTP status codes
        switch (error.response.status) {
          case 400:
            errorMessage = 'Bad request. Please check your input and try again.';
            break;
          case 401:
            errorMessage = 'Your session has expired. Please log in again.';
            break;
          case 403:
            errorMessage = 'Access forbidden. You do not have permission to perform this action.';
            break;
          case 404:
            errorMessage = 'Resource not found. The requested item may have been deleted or moved.';
            break;
          case 409:
            errorMessage = 'Conflict. The resource already exists or conflicts with current state.';
            break;
          case 422:
            errorMessage = 'Validation error. Please check your input and try again.';
            break;
          case 500:
            errorMessage = 'Internal server error. Please try again later or contact support.';
            break;
          case 502:
            errorMessage = 'Bad gateway. The server is temporarily unavailable.';
            break;
          case 503:
            errorMessage = 'Service unavailable. Please try again later.';
            break;
          default:
            errorMessage = `Server error (${error.response.status}): ${error.response.statusText || 'Unknown error'}`;
        }
      } else {
        errorMessage = 'Server returned an error response';
      }
    } else if (error.request) {
      // Request was made but no response received
      errorMessage = 'No response from server. Please check your connection and try again.';
    } else if (error.message) {
      errorMessage = error.message;
    } else {
      errorMessage = 'An unexpected error occurred';
    }
    
    // Create a new error with the properly formatted message
    const apiError = new Error(errorMessage);
    Object.assign(apiError, error);
    
    console.error('API Error:', errorMessage);
    return Promise.reject(apiError);
  }
);

export const organizationsApi = {
  create: async (data: OrganizationCreateRequest): Promise<Organization> => {
    const response: AxiosResponse<Organization> = await api.post('/organizations', data);
    return response.data;
  },

  list: async (filters?: OrganizationFilters): Promise<OrganizationList> => {
    const response: AxiosResponse<OrganizationList> = await api.get('/organizations', {
      params: filters,
    });
    return response.data;
  },

  getById: async (orgId: string): Promise<Organization> => {
    const response: AxiosResponse<Organization> = await api.get(`/organizations/${orgId}`);
    return response.data;
  },

  getByName: async (name: string): Promise<Organization> => {
    const response: AxiosResponse<Organization> = await api.get(`/organizations/search/by-name/${name}`);
    return response.data;
  },

  update: async (orgId: string, data: OrganizationUpdateRequest): Promise<Organization> => {
    const response: AxiosResponse<Organization> = await api.put(`/organizations/${orgId}`, data);
    return response.data;
  },

  delete: async (orgId: string): Promise<OrganizationDeleteResponse> => {
    const response: AxiosResponse<OrganizationDeleteResponse> = await api.delete(`/organizations/${orgId}`);
    return response.data;
  },

  getStats: async (): Promise<any> => {
    const response = await api.get('/organizations/stats');
    return response.data;
  },
};

export const usersApi = {
  create: async (orgId: string, data: UserCreateRequest): Promise<User> => {
    const response: AxiosResponse<User> = await api.post(`/organizations/${orgId}/users`, data);
    return response.data;
  },

  list: async (orgId: string, filters?: UserFilters): Promise<UserList> => {
    const response: AxiosResponse<UserList> = await api.get(`/organizations/${orgId}/users`, {
      params: filters,
    });
    return response.data;
  },

  getById: async (orgId: string, userId: string): Promise<User> => {
    const response: AxiosResponse<User> = await api.get(`/organizations/${orgId}/users/${userId}`);
    return response.data;
  },

  getByEmail: async (orgId: string, email: string): Promise<User> => {
    const response: AxiosResponse<User> = await api.get(`/organizations/${orgId}/users/search/by-email/${email}`);
    return response.data;
  },

  getByUsername: async (orgId: string, username: string): Promise<User> => {
    const response: AxiosResponse<User> = await api.get(`/organizations/${orgId}/users/search/by-username/${username}`);
    return response.data;
  },

  update: async (orgId: string, userId: string, data: UserUpdateRequest): Promise<User> => {
    const response: AxiosResponse<User> = await api.put(`/organizations/${orgId}/users/${userId}`, data);
    return response.data;
  },

  delete: async (orgId: string, userId: string): Promise<UserDeleteResponse> => {
    const response: AxiosResponse<UserDeleteResponse> = await api.delete(`/organizations/${orgId}/users/${userId}`);
    return response.data;
  },

  getStats: async (orgId: string): Promise<any> => {
    try {
      const response = await api.get(`/organizations/${orgId}/users/stats/summary`);
      
      // If we get a fallback response, handle it gracefully
      if (response.data?.fallback) {
        console.warn('Using fallback data for user stats due to backend issues');
        return response.data.data; // Return just the data part, not the wrapper
      }
      
      return response.data;
    } catch (error) {
      console.error('Failed to fetch user stats, returning fallback data:', error);
      // Return default fallback data if API call fails completely
      return {
        total_users: 0,
        active_users: 0,
        inactive_users: 0,
        recent_registrations: 0,
        user_roles: {
          admin: 0,
          user: 0,
          viewer: 0
        }
      };
    }
  },
};

export const healthApi = {
  check: async (): Promise<HealthCheck> => {
    const response: AxiosResponse<HealthCheck> = await api.get('/health');
    return response.data;
  },

  status: async (): Promise<any> => {
    const response = await api.get('/status');
    return response.data;
  },

  ready: async (): Promise<any> => {
    const response = await api.get('/ready');
    return response.data;
  },

  live: async (): Promise<any> => {
    const response = await api.get('/live');
    return response.data;
  },

  metrics: async (): Promise<any> => {
    const response = await api.get('/metrics');
    return response.data;
  },
};

export const authApi = {
  login: async (credentials: LoginRequest): Promise<LoginResponse> => {
    const response: AxiosResponse<LoginResponse> = await api.post('/auth/login', credentials);
    return response.data;
  },

  register: async (data: RegisterRequest): Promise<RegisterResponse> => {
    const response: AxiosResponse<RegisterResponse> = await api.post('/auth/register', data);
    return response.data;
  },

  getOrganizations: async (): Promise<Organization[]> => {
    const response: AxiosResponse<Organization[]> = await api.get('/auth/organizations');
    return response.data;
  },

  getCurrentUser: async (): Promise<SessionUser> => {
    const response: AxiosResponse<SessionUser> = await api.get('/auth/me');
    return response.data;
  },

  logout: async (): Promise<LogoutResponse> => {
    const response = await fetch('/api/auth/logout', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authService.getAccessToken() || ''}`
      }
    });
    return await response.json();
  },
};

export const foldersApi = {
  list: async (orgId: string, filters?: FolderFilters): Promise<FolderList> => {
    const params = new URLSearchParams();
    if (filters?.page) params.append('page', filters.page.toString());
    if (filters?.per_page) params.append('per_page', filters.per_page.toString());
    if (filters?.name) params.append('name', filters.name);
    if (filters?.parent_folder_id) params.append('parent_folder_id', filters.parent_folder_id);
    
    const response: AxiosResponse<FolderList> = await api.get(
      `/organizations/${orgId}/folders${params.toString() ? `?${params.toString()}` : ''}`
    );
    return response.data;
  },

  getById: async (orgId: string, folderId: string): Promise<Folder> => {
    const response: AxiosResponse<Folder> = await api.get(`/organizations/${orgId}/folders/${folderId}`);
    return response.data;
  },

  create: async (orgId: string, data: FolderCreateRequest): Promise<Folder> => {
    if (!orgId) {
      throw new Error('Organization ID is required to create a folder');
    }
    if (!data.name || data.name.trim() === '') {
      throw new Error('Folder name is required');
    }
    
    // Get current user information for user_id parameter
    const currentUser = authService.getUser();
    if (!currentUser) {
      throw new Error('No authenticated user found. Please login first.');
    }
    
    // Validate user belongs to the organization
    if (currentUser.org_id !== orgId) {
      throw new Error('Access denied: Cannot create folder in different organization.');
    }
    
    console.log('Creating folder:', { 
      orgId, 
      data, 
      userId: currentUser.user_id,
      orgName: currentUser.org_name
    });
    
    // Add user_id as query parameter as required by the backend
    const response: AxiosResponse<Folder> = await api.post(
      `/organizations/${orgId}/folders?user_id=${currentUser.user_id}`, 
      data
    );
    return response.data;
  },

  update: async (orgId: string, folderId: string, data: FolderUpdateRequest): Promise<Folder> => {
    const response: AxiosResponse<Folder> = await api.put(`/organizations/${orgId}/folders/${folderId}`, data);
    return response.data;
  },

  delete: async (orgId: string, folderId: string): Promise<FolderDeleteResponse> => {
    const response: AxiosResponse<FolderDeleteResponse> = await api.delete(`/organizations/${orgId}/folders/${folderId}`);
    return response.data;
  },

  getTree: async (orgId: string): Promise<FolderTree> => {
    const response: AxiosResponse<FolderTree> = await api.get(`/organizations/${orgId}/folders/tree`);
    return response.data;
  },

  move: async (orgId: string, folderId: string, data: FolderMoveRequest): Promise<Folder> => {
    const response: AxiosResponse<Folder> = await api.put(`/organizations/${orgId}/folders/${folderId}/move`, data);
    return response.data;
  },

  getPath: async (orgId: string, folderId: string): Promise<{ path: string }> => {
    const response: AxiosResponse<{ path: string }> = await api.get(`/organizations/${orgId}/folders/${folderId}/path`);
    return response.data;
  },

  getStats: async (orgId: string): Promise<FolderStats> => {
    const response: AxiosResponse<FolderStats> = await api.get(`/organizations/${orgId}/folders/stats`);
    return response.data;
  },
};

// Add connection testing utility
export const testApiConnection = async (): Promise<{ success: boolean; error?: string }> => {
  try {
    // Test basic connectivity
    const response = await fetch(`${API_BASE_URL}`.replace('/api/v1', '/health'), {
      method: 'GET',
      mode: 'cors',
      cache: 'no-cache'
    });
    
    if (response.ok) {
      return { success: true };
    } else {
      return { success: false, error: `HTTP ${response.status}: ${response.statusText}` };
    }
  } catch (error) {
    return { success: false, error: error instanceof Error ? error.message : String(error) };
  }
};

// Simplified session authentication check
export const checkSessionStatus = (): { hasToken: boolean; isExpired: boolean; isValid: boolean; sessionInfo: any } => {
  const token = authService.getAccessToken();
  
  return {
    hasToken: !!token,
    isExpired: authService.isAccessTokenExpired(),
    isValid: authService.isAuthenticated(),
    sessionInfo: authService.getSessionDebugInfo()
  };
};

// Helper function for constructing folder paths (DRY - used by both upload and list)
const constructFolderPath = async (orgId: string, folderId: string): Promise<string> => {
  const currentUser = authService.getUser();
  if (!currentUser) {
    throw new Error('No authenticated user found. Please login first.');
  }

  // Resolve folder name from ID (same logic as upload)
  const folderDetails = await foldersApi.getById(orgId, folderId);
  const folderName = folderDetails.name;
  const orgName = currentUser.org_name;
  
  // Construct path: {orgName}/original/{folderName}
  return `${orgName}/original/${folderName}`;
};

export const documentsApi = {
  list: async (organizationId: string, filters?: DocumentFilters): Promise<DocumentList> => {
    // Get user information for authorization
    const currentUser = authService.getUser();
    if (!currentUser) {
      throw new Error('No authenticated user found. Please login first.');
    }

    if (currentUser.org_id !== organizationId) {
      throw new Error('Access denied: Cannot list documents from different organization.');
    }

    try {
      const response: AxiosResponse<DocumentList> = await api.get(`/documents`, {
        params: filters,
      });

      console.log('üîí Document list retrieved:', {
        totalDocuments: response.data.total,
        documentsReturned: response.data.documents.length,
        orgId: organizationId
      });

      return response.data;
    } catch (error) {
      console.error('üîí Document list request failed:', error);

      if (error instanceof Error) {
        if (error.message.includes('Network Error') || error.message.includes('ERR_NETWORK')) {
          throw new Error('Cannot connect to the server. Please check your connection.');
        } else if (error.message.includes('401') || error.message.includes('403')) {
          throw new Error('Access denied. Please log in again to view documents.');
        } else {
          throw error;
        }
      }
      throw error;
    }
  },

  upload: async (
    file: File,
    organizationId: string,
    folderId?: string,
    onUploadProgress?: (progressEvent: any) => void
  ): Promise<Document> => {
    console.log('üîí === SENSITIVE DOCUMENT UPLOAD START ===');
    console.log('üîí Upload parameters (SENSITIVE):', {
      fileName: file.name,
      fileSize: file.size,
      fileType: file.type,
      organizationId,
      folderId,
      apiBaseUrl: API_BASE_URL,
      timestamp: new Date().toISOString()
    });

    // Get user and organization information from session
    const currentUser = authService.getUser();
    if (!currentUser) {
      throw new Error('No authenticated user found. Please login first.');
    }

    console.log('üîí Session user details (SENSITIVE):', {
      userId: currentUser.user_id,
      userEmail: currentUser.email,
      orgId: currentUser.org_id,
      orgName: currentUser.org_name,
      sessionId: currentUser.session_id,
      hasToken: !!authService.getAccessToken(),
      isValid: authService.isAuthenticated(),
      isExpired: authService.isAccessTokenExpired()
    });

    try {
      console.log('üîí Preparing secure upload form data...');
      
      // Step 1: Resolve folder name if folderId is provided
      let folderName: string | null = null;
      if (folderId) {
        console.log('üîí Resolving folder name for sensitive document upload...');
        try {
          const folderDetails = await foldersApi.getById(currentUser.org_id, folderId);
          folderName = folderDetails.name;
          console.log('üîí Folder resolved (SENSITIVE):', {
            folderId: folderId,
            folderName: folderName,
            orgId: currentUser.org_id
          });
        } catch (error) {
          console.error('üö´ Failed to resolve folder for sensitive upload:', error);
          throw new Error(`Unable to resolve folder (${folderId}). Upload cannot proceed for security reasons.`);
        }
      }

      // Step 2: Construct secure target path according to API requirements
      // Note: API requires folder to always be present - no root-level uploads allowed
      if (!folderId) {
        throw new Error('Folder selection is required. The API does not support root-level document uploads for security reasons.');
      }

      const orgName = currentUser.org_name; // Use actual organization name as provided
      const fileName = file.name;
      const targetPath = `${orgName}/original/${folderName}/${fileName}`; // No leading slash

      console.log('üîí Constructed secure target path (SENSITIVE):', {
        orgName: orgName,
        folderName: folderName,
        fileName: fileName,
        targetPath: targetPath,
        pathConstruction: 'FOLDER_REQUIRED',
        apiRequirement: 'NO_ROOT_UPLOADS_ALLOWED'
      });

      // Step 3: Prepare form data with all required parameters
      const formData = new FormData();
      formData.append('file', file);
      formData.append('organization_id', organizationId);
      formData.append('target_path', targetPath);
      
      if (folderId) {
        formData.append('folder_id', folderId);
      }

      console.log('üîí Starting secure document upload (SENSITIVE)...');
      console.log('üîí Final upload parameters (SENSITIVE):', {
        fileName: file.name,
        fileSize: file.size,
        fileType: file.type,
        organizationId: organizationId,
        orgName: orgName,
        folderId: folderId,
        folderName: folderName,
        targetPath: targetPath,
        endpoint: `${API_BASE_URL}/documents/upload`,
        formDataKeys: Array.from(formData.keys()),
        securityLevel: 'HIGH_SENSITIVITY',
        timestamp: new Date().toISOString()
      });

      // Step 2: Upload the document directly
      const response: AxiosResponse<DocumentUploadResponse> = await api.post(
        `/documents/upload`,
        formData,
        {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
          onUploadProgress: (progressEvent) => {
            if (progressEvent.total) {
              const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);
              console.log(`Upload progress: ${progress}%`);
            }
            if (onUploadProgress) {
              onUploadProgress(progressEvent);
            }
          },
        }
      );
      
      console.log('üîí ‚úÖ Secure document upload completed successfully (SENSITIVE)');
      console.log('üîí Upload response (SENSITIVE):', {
        success: true,
        fileName: file.name,
        orgName: orgName,
        targetPath: targetPath,
        responseStatus: response.status,
        responseSize: JSON.stringify(response.data).length,
        timestamp: new Date().toISOString(),
        securityLevel: 'HIGH_SENSITIVITY'
      });
      console.log('üîí === SENSITIVE DOCUMENT UPLOAD END ===');
      
      return response.data.document;
    } catch (error) {
      console.error('üîí üö´ SENSITIVE DOCUMENT UPLOAD FAILED (SECURITY ALERT)');
      console.error('üîí Upload error details (SENSITIVE):', {
        fileName: file.name,
        orgName: currentUser?.org_name || 'UNKNOWN',
        orgId: currentUser?.org_id || 'UNKNOWN',
        folderId: folderId,
        errorType: error instanceof Error ? error.constructor.name : 'Unknown',
        errorMessage: error instanceof Error ? error.message : String(error),
        timestamp: new Date().toISOString(),
        securityLevel: 'HIGH_SENSITIVITY_ERROR'
      });
      
      // Enhanced error handling with security considerations
      if (error instanceof Error) {
        // Network/connection errors
        if (error.message.includes('Network Error') || error.message.includes('ERR_NETWORK')) {
          console.error('üö´ Network connection failed during sensitive upload');
          throw new Error('Cannot connect to the server. Please check your connection and retry the sensitive document upload.');
        } 
        // Timeout errors
        else if (error.message.includes('timeout')) {
          console.error('üö´ Upload timeout during sensitive document upload');
          throw new Error('Upload timed out. Please try a smaller file or retry the upload.');
        }
        // Folder resolution errors (specific to our new logic)
        else if (error.message.includes('Unable to resolve folder')) {
          console.error('üö´ Folder resolution failed for sensitive upload');
          throw error; // Re-throw our custom folder error
        }
        // Authentication/authorization errors
        else if (error.message.includes('401') || error.message.includes('403')) {
          console.error('üö´ Authentication/authorization failed for sensitive upload');
          throw new Error('Authentication failed. Please log in again to upload sensitive documents.');
        }
        // Generic API errors
        else {
          console.error('üö´ Upload failed with error:', error.message);
          // Let the original error bubble up - API interceptor will handle auth issues
          throw error;
        }
      }
      
      console.error('üîí === SENSITIVE DOCUMENT UPLOAD ERROR END ===');
      throw error;
    }
  },

  // Firestore API for listing documents by folder name (primary method)
  listByFolderName: async (folderName: string): Promise<{ success: boolean; data?: DocumentList; shouldFallback?: boolean; error?: string }> => {
    // Get user information for authorization
    const currentUser = authService.getUser();
    if (!currentUser) {
      throw new Error('No authenticated user found. Please login first.');
    }

    try {
      console.log('üîÑ Using Firestore API for folder documents:', { folderName });

      const response: AxiosResponse<DocumentList> = await api.get(
        `/documents/firestore/by-folder-name/${encodeURIComponent(folderName)}`
      );

      console.log('‚úÖ Firestore API succeeded:', {
        totalDocuments: response.data.total,
        documentsReturned: response.data.documents.length,
        folderName
      });

      return { success: true, data: response.data };
    } catch (error: any) {
      // Log the error for debugging
      console.warn('‚ö†Ô∏è Firestore API failed, will use GCP bucket fallback:', error.message || error);

      // For any Firestore API failure, we'll fall back to GCP bucket approach
      // This includes network issues, service downtime, rate limits, etc.
      if (error.response) {
        const status = error.response.status;
        
        if (status === 401 || status === 403) {
          // Auth errors should be thrown as they affect both APIs
          throw new Error('Access denied. Please log in again to view documents.');
        }
        
        // All other HTTP errors trigger fallback
        return { 
          success: false, 
          shouldFallback: true, 
          error: `Firestore API returned ${status}, using GCP bucket fallback` 
        };
      } else if (error.request) {
        // Network errors trigger fallback
        return { 
          success: false, 
          shouldFallback: true, 
          error: 'Network error with Firestore API, using GCP bucket fallback' 
        };
      } else {
        // Any other error triggers fallback
        return { 
          success: false, 
          shouldFallback: true, 
          error: `Firestore API error: ${error.message || 'Unknown error'}, using GCP bucket fallback` 
        };
      }
    }
  },

  // Document Summarization API Methods
  getSummary: async (document: Document): Promise<DocumentSummary> => {
    const currentUser = authService.getUser();
    if (!currentUser) {
      throw new Error('No authenticated user found. Please login first.');
    }

    try {
      console.log('üìÑ Fetching summary for document:', document.name);
      
      // Include both document_id and file_name as query parameters as required by the backend API
      const queryParams = new URLSearchParams({
        document_id: document.id,
        file_name: document.name
      });
      
      const response: AxiosResponse<DocumentSummaryResponse> = await api.get(
        `/documents/summarize?${queryParams.toString()}`
      );
      
      console.log('‚úÖ Summary fetched successfully for:', document.name);
      console.log('üìä Response structure:', response.data);
      
      // Convert backend response to frontend format
      if (!response.data.ai_summary) {
        throw new Error('No summary found for this document');
      }
      
      const documentSummary: DocumentSummary = {
        id: `${response.data.document_id}-summary`,
        document_id: response.data.document_id,
        content: response.data.ai_summary,
        metadata: response.data.summary_metadata,
        created_at: response.data.updated_at || new Date().toISOString(),
        updated_at: response.data.updated_at || new Date().toISOString()
      };
      
      return documentSummary;
    } catch (error) {
      console.error('üö´ Summary fetch failed:', error);
      throw error;
    }
  },

  generateSummary: async (document: Document, options?: DocumentSummaryRequest['options']): Promise<DocumentSummarizeResponse> => {
    const currentUser = authService.getUser();
    if (!currentUser) {
      throw new Error('No authenticated user found. Please login first.');
    }

    try {
      console.log('üìÑ Generating summary for document:', document.name);
      
      const requestData: DocumentSummaryRequest = {
        options: options || {}
      };
      
      // Include file_name as query parameter as required by the backend API
      const queryParams = new URLSearchParams({
        file_name: document.name
      });
      
      const response: AxiosResponse<DocumentSummarizeResponse> = await api.post(
        `/documents/summarize?${queryParams.toString()}`,
        {
          document_id: document.id,
          ...requestData
        }
      );
      
      console.log('‚úÖ Summary generated successfully for:', document.name);
      console.log('üìä Response structure:', response.data);
      return response.data;
    } catch (error) {
      console.error('üö´ Summary generation failed:', error);
      throw error;
    }
  },

  updateSummary: async (document: Document, updateData: DocumentSummaryUpdateRequest): Promise<DocumentSummarizeResponse> => {
    const currentUser = authService.getUser();
    if (!currentUser) {
      throw new Error('No authenticated user found. Please login first.');
    }

    try {
      console.log('üìÑ Updating summary for document:', document.name);
      
      // Include file_name as query parameter as required by the backend API
      const queryParams = new URLSearchParams({
        file_name: document.name
      });
      
      const response: AxiosResponse<DocumentSummarizeResponse> = await api.put(
        `/documents/summarize?${queryParams.toString()}`,
        {
          document_id: document.id,
          ...updateData
        }
      );
      
      console.log('‚úÖ Summary updated successfully for:', document.name);
      return response.data;
    } catch (error) {
      console.error('üö´ Summary update failed:', error);
      throw error;
    }
  },

  // Document FAQ API Methods
  getFAQ: async (document: Document): Promise<DocumentFAQ> => {
    const currentUser = authService.getUser();
    if (!currentUser) {
      throw new Error('No authenticated user found. Please login first.');
    }

    try {
      console.log('‚ùì Fetching FAQ for document:', document.name);
      
      // Include both document_id and file_name as query parameters as required by the backend API
      const queryParams = new URLSearchParams({
        document_id: document.id,
        file_name: document.name
      });
      
      const response: AxiosResponse<DocumentFAQRetrievalResponse> = await api.get(
        `/documents/faq?${queryParams.toString()}`
      );
      
      console.log('‚úÖ FAQ fetched successfully for:', document.name);
      console.log('üìä Response structure:', response.data);
      
      // Convert backend response to frontend format
      if (!response.data.ai_faq || !response.data.has_faq) {
        throw new Error('No FAQ found for this document');
      }
      
      const documentFAQ: DocumentFAQ = {
        id: `${response.data.document_id}-faq`,
        document_id: response.data.document_id,
        faqs: response.data.ai_faq.map(item => ({
          question: item.question,
          answer: item.answer
        })),
        metadata: response.data.faq_metadata,
        created_at: response.data.updated_at || new Date().toISOString(),
        updated_at: response.data.updated_at || new Date().toISOString()
      };
      
      return documentFAQ;
    } catch (error) {
      console.error('üö´ FAQ fetch failed:', error);
      throw error;
    }
  },

  generateFAQ: async (document: Document, options?: { prompt?: string; faq_count?: number }): Promise<DocumentFAQResponse> => {
    const currentUser = authService.getUser();
    if (!currentUser) {
      throw new Error('No authenticated user found. Please login first.');
    }

    try {
      console.log('‚ùì Generating FAQ for document:', document.name);
      
      const requestData: DocumentFAQRequest = {
        prompt: options?.prompt,
        faq_count: options?.faq_count || 5
      };
      
      // Include file_name as query parameter as required by the backend API
      const queryParams = new URLSearchParams({
        file_name: document.name
      });
      
      const response: AxiosResponse<DocumentFAQResponse> = await api.post(
        `/documents/faq?${queryParams.toString()}`,
        {
          document_id: document.id,
          ...requestData
        }
      );
      
      console.log('‚úÖ FAQ generated successfully for:', document.name);
      console.log('üìä Response structure:', response.data);
      return response.data;
    } catch (error) {
      console.error('üö´ FAQ generation failed:', error);
      throw error;
    }
  },

  updateFAQ: async (document: Document, updateData: DocumentFAQUpdateRequest): Promise<DocumentFAQResponse> => {
    const currentUser = authService.getUser();
    if (!currentUser) {
      throw new Error('No authenticated user found. Please login first.');
    }

    try {
      console.log('‚ùì Updating FAQ for document:', document.name);
      
      // Include file_name as query parameter as required by the backend API
      const queryParams = new URLSearchParams({
        file_name: document.name
      });
      
      const response: AxiosResponse<DocumentFAQResponse> = await api.put(
        `/documents/faq?${queryParams.toString()}`,
        {
          document_id: document.id,
          ...updateData
        }
      );
      
      console.log('‚úÖ FAQ updated successfully for:', document.name);
      console.log('üìä Response structure:', response.data);
      return response.data;
    } catch (error) {
      console.error('üö´ FAQ update failed:', error);
      throw error;
    }
  },

  // Document Questions API Methods
  getQuestions: async (document: Document): Promise<DocumentQuestions> => {
    const currentUser = authService.getUser();
    if (!currentUser) {
      throw new Error('No authenticated user found. Please login first.');
    }

    try {
      const queryParams = new URLSearchParams({
        file_name: document.name
      });
      
      const response: AxiosResponse<DocumentQuestionsRetrievalResponse> = await api.get(
        `/documents/questions?${queryParams.toString()}`
      );
      
      // Convert backend response to frontend format
      const backendData = response.data;
      const frontendQuestions: DocumentQuestions = {
        id: `questions_${backendData.document_id}`,
        document_id: backendData.document_id,
        questions: (backendData.ai_questions || []).map((questionText: string) => ({
          question: questionText,
          type: 'short_answer' as const,
        })),
        metadata: backendData.questions_metadata || {},
        created_at: backendData.updated_at || new Date().toISOString(),
        updated_at: backendData.updated_at || new Date().toISOString()
      };
      
      return frontendQuestions;
    } catch (error) {
      console.error('üö´ Questions fetch failed:', error);
      throw error;
    }
  },

  generateQuestions: async (document: Document, options?: { prompt?: string; question_count?: number }): Promise<DocumentQuestionsResponse> => {
    const currentUser = authService.getUser();
    if (!currentUser) {
      throw new Error('No authenticated user found. Please login first.');
    }

    try {
      const queryParams = new URLSearchParams({
        file_name: document.name
      });
      
      const requestData: DocumentQuestionsRequest = {
        prompt: options?.prompt,
        question_count: options?.question_count || 5
      };
      
      const response: AxiosResponse<DocumentQuestionsResponse> = await api.post(
        `/documents/questions?${queryParams.toString()}`,
        requestData
      );
      
      return response.data;
    } catch (error) {
      console.error('üö´ Questions generation failed:', error);
      throw error;
    }
  },

  updateQuestions: async (document: Document, updateData: DocumentQuestionsUpdateRequest): Promise<DocumentQuestionsResponse> => {
    const currentUser = authService.getUser();
    if (!currentUser) {
      throw new Error('No authenticated user found. Please login first.');
    }

    try {
      const queryParams = new URLSearchParams({
        file_name: document.name
      });
      
      const response: AxiosResponse<DocumentQuestionsResponse> = await api.put(
        `/documents/questions?${queryParams.toString()}`,
        updateData
      );
      
      return response.data;
    } catch (error) {
      console.error('üö´ Questions update failed:', error);
      throw error;
    }
  },
};

export default api;